# По ТЗ

## Демонстрация

https://github.com/user-attachments/assets/a6b4443a-e473-4797-97cd-84c64a269bba

## Реализованные features

### 1. Настройки приложения

Реализована фича настроек с возможностью смены темы приложения (светлая/темная).

#### Функциональность:
- Переключение между светлой и темной темой через интуитивный переключатель
- Автоматическое сохранение выбранной темы между сессиями приложения
- Динамическое применение темы ко всему интерфейсу без перезапуска
- Центрированные заголовки на всех экранах приложения
- Разделители между элементами настроек для лучшей читаемости

#### Архитектура:
Фича реализована согласно принципам Clean Architecture с разделением на слои:

**Domain Layer:**
- `ThemeType` - enum для типов темы (light, dark)
- `AppSettings` - сущность с настройками приложения
- `ISettingsRepository` - интерфейс репозитория для работы с настройками

**Data Layer:**
- `SettingsRepository` - реализация репозитория с использованием SharedPreferences, наследуется от `BaseRepository`
- `ThemeTypeMapper` - маппер для преобразования enum в строку для сохранения

**UI Layer:**
- `SettingsModel` - управление состоянием настроек, интеграция с ThemeManager
- `SettingsWM` - обработка пользовательских действий (изменение темы)
- `SettingsScreen` - основной виджет экрана с динамическим обновлением цветов
- `SettingsScreenBuilder` - сборка локальных зависимостей
- `ThemeToggleWidget` - переключатель темы с подписью "Тёмная тема"

**App Level:**
- `ThemeManager` - глобальный менеджер для управления темой приложения
- `App` - обновлен для использования ThemeManager и динамического переключения тем
- `AppThemeData` - содержит готовые светлую и темную темы с правильными цветовыми схемами

#### Интеграция:
- Экран настроек интегрирован в `TabsScreen` заменой заглушки на `SettingsScreenBuilder`
- `ISettingsRepository` и `IThemeManager` добавлены в глобальные зависимости `AppDependencies`
- Локальные зависимости настроек изолированы в `SettingsDependencies`
- Все заголовки приложения центрированы через обновление `AppBarTheme`
- Тема инициализируется при запуске приложения и сохраняется

### 2. Экран "Избранное"

Реализован экран для просмотра и управления избранными местами.

#### Функциональность:
- Отображение списка избранных мест в виде карточек
- Пустое состояние с иконкой и текстом при отсутствии избранных мест
- Удаление мест из избранного через свайп или нажатие на крестик
- Переход к детальной информации о месте при нажатии на карточку
- Адаптивный UI с поддержкой темной и светлой темы

#### Архитектура:
Фича реализована согласно принципам Clean Architecture с разделением на слои:

**Domain Layer:**
- `FavoritesState` - состояния экрана (Loading, Empty, Data)

**UI Layer:**
- `FavoritesModel` - управление состоянием экрана, подписка на изменения избранного через `IFavoritesRepository`
- `FavoritesWM` - обработка пользовательских действий (нажатие на карточку, удаление из избранного), управление навигацией
- `FavoritesScreen` - основной виджет экрана с `AppBar` и обработкой состояний
- `FavoritesScreenBuilder` - сборка зависимостей
- `FavoritesListWidget` - виджет списка избранных мест с поддержкой свайпа для удаления
- `FavoritesEmptyWidget` - виджет пустого состояния
- `DismissibleBackgroundWidget` - фон для свайпа с иконкой корзины

**Widgets:**
- Расширен `PlaceCardWidget` поддержкой типа карточки (`PlaceCardType.favorite`)
- В режиме избранного отображается крестик вместо сердца
- Заполненное сердце отображается красным цветом на обычных карточках

#### Интеграция:
- Экран интегрирован в `TabsScreen` заменой заглушки на `FavoritesScreenBuilder`
- Использует существующий `IFavoritesRepository` для получения данных
- Переиспользует `PlaceCardWidget` для единообразного отображения карточек

### 3. Сплэш экран

Реализован сплэш экран с логотипом приложения, который отображается при запуске на 2 секунды.

#### Функциональность:
- Отображение логотипа приложения на градиентном фоне
- Автоматическое определение первого запуска приложения
- Навигация на онбординг при первом запуске
- Навигация на главный экран при повторных запусках
- Плавная анимация исчезновения

**Domain Layer:**
- `SplashState` - состояния сплэш экрана (Loading, Completed)
- `IFirstLaunchRepository` - интерфейс для работы с настройками первого запуска

**Data Layer:**
- `FirstLaunchRepository` - реализация репозитория с использованием SharedPreferences для сохранения информации о первом запуске

**UI Layer:**
- `SplashModel` - управление состоянием и бизнес-логикой (таймер 2 секунды, проверка первого запуска)
- `SplashWM` - обработка навигации и управление жизненным циклом
- `SplashScreen` - виджет с градиентным фоном и логотипом
- `SplashScreenBuilder` - сборка зависимостей и создание экрана

#### Интеграция:
- Сплэш экран интегрирован в корневой виджет приложения как стартовый экран
- Настроены маршруты для навигации на `/places` и `/onboarding` (не успел)


---
---

# Surf Places

Проект для поиска и сохранения интересных мест.

## API
Swagger с описание api доступен по ссылке http://109.73.206.134:8888/docs/student/

## Архитектура

Проект построен на основе принципов **Clean Architecture** и использует подход **Feature-First**. Основная цель такой архитектуры — разделение ответственностей, тестируемость и простота поддержки.

### Структура проекта

Код приложения находится в директории `lib` и организован следующим образом:

- **lib/**
  - `api/`: Код для взаимодействия с API (модели DTO, клиенты Retrofit).
  - `assets/`: Строковые константы и пути к ассетам.
  - `core/`: Ядро приложения. Содержит базовые классы, утилиты и абстракции, не зависящие от бизнес-логики (например, базовый репозиторий, обработка ошибок).
  - `features/`: Основная директория с фичами приложения.
    - `app/`: Корневой виджет приложения и настройка DI.
    - `common/`: Общие для нескольких фич виджеты, сущности, репозитории и т.д.
    - `имя_фичи/`: Изолированный модуль с конкретной функциональностью.
      - `data/`: Слой данных (реализации репозиториев, работа с API и БД).
      - `domain/`: Слой доменной логики (сущности, интерфейсы репозиториев, интеракторы).
      - `ui/`: Слой представления (экраны, виджеты, WidgetModels).
  - `uikit/`: Набор переиспользуемых UI-компонентов (кнопки, кастомные виджеты, темы).
  - `main.dart`: Точка входа в приложение для `prod` окружения.
  - `runner.dart`: Инициализация и запуск приложения.

### Схема слоев

Каждая фича разделена на три слоя: `UI`, `Domain`, `Data`.

- **Data Layer**: Отвечает за получение данных из внешних источников (сеть, база данных). Содержит реализации репозиториев, DTO (Data Transfer Objects) и мапперы для преобразования DTO в доменные сущности. **Важно**: все репозитории должны наследоваться от `BaseRepository` из `lib/core/data/repositories/base_repository.dart` для унификации обработки запросов и ошибок.
- **Domain Layer**: Содержит бизнес-логику приложения. Не зависит от других слоев. Включает в себя доменные модели (Entities) и интерфейсы (контракты) репозиториев.
- **UI Layer**: Отвечает за отображение данных. Использует связку **Screen-WM-Model**.
  - **Screen (Widget)**: Декларативное описание интерфейса. Не содержит логики, кроме как передачи пользовательских событий в `WidgetModel`.
  - **WidgetModel (WM)**: Посредник между `Screen` и `Model`. Обрабатывает пользовательские действия, управляет навигацией и передает данные для отображения в `Screen`.
  - **Model**: Содержит логику управления состоянием экрана. Взаимодействует с `Domain Layer` (через репозитории), выполняет бизнес-логику, обрабатывает данные и предоставляет их `WM` через `ValueListenable`.

### Управление зависимостями (DI)

В проекте используется `provider` для внедрения зависимостей. Зависимости делятся на два уровня:

- **Глобальные (`AppDependencies`)**: Зависимости, которые используются в нескольких фичах или во всем приложении (например, `ApiClient`, `IFavoritesRepository`). Они объявляются в `lib/features/app/di/app_dependencies.dart`.
- **Локальные (`FeatureDependencies`)**: Зависимости, необходимые только для одной конкретной фичи. Они объявляются в файле `dependencies.dart` внутри директории фичи (например, `lib/features/places/ui/places_dependencies.dart`). Это позволяет сохранять модульность и не загрязнять глобальное пространство имен.

## Создание новой фичи

Чтобы добавить новую фичу (например, `UserProfile`), следуйте шагам:

1.  **Создайте структуру директорий**:

    ```
    lib/features/user_profile/
    ├── data/
    │   ├── repositories/
    │   │   └── user_profile_repository.dart
    │   └── ...
    ├── domain/
    │   ├── enitites/
    │   │   └── user_profile_entity.dart
    │   └── reposiotries/
    │       └── i_user_profile_repository.dart
    └── ui/
        ├── screens/
        │   ├── user_profile_model.dart
        │   ├── user_profile_screen_builder.dart
        │   ├── user_profile_screen.dart
        │   └── user_profile_wm.dart
        └── widgets/
    ```

2.  **Domain Layer**:
    - Создайте сущность `UserProfileEntity`.
    - Определите контракт в `i_user_profile_repository.dart`.

    ```dart
    // lib/features/user_profile/domain/reposiotries/i_user_profile_repository.dart
    abstract interface class IUserProfileRepository {
      Future<UserProfileEntity> getUserProfile();
    }
    ```

3.  **Data Layer**:
    - Создайте DTO (если нужно) и маппер.
    - Реализуйте `IUserProfileRepository` в `user_profile_repository.dart`, унаследовав его от `BaseRepository`.

    ```dart
    // lib/features/user_profile/data/repositories/user_profile_repository.dart
    class UserProfileRepository extends BaseRepository implements IUserProfileRepository {
      // ...
    }
    ```

4.  **UI Layer**:
    - Создайте `UserProfileModel`, который будет реализовывать логику состояния.
    - Создайте `UserProfileWM`, который будет использовать `UserProfileModel` и `IUserProfileRepository`.
    - Создайте `UserProfileScreen`, который будет отображать данные из `UserProfileWM`.
    - Свяжите все в `user_profile_screen_builder.dart`, который создаст WM и передаст его в экран.

5.  **Добавьте зависимости**:
    - **Глобальные зависимости**: Если репозиторий или сервис будет использоваться в нескольких фичах, добавьте его провайдер в `lib/features/app/di/app_dependencies.dart`.
    - **Локальные зависимости**: Для зависимостей, специфичных для `UserProfile`, создайте файл `lib/features/user_profile/ui/user_profile_dependencies.dart`.

    ```dart
    // lib/features/user_profile/ui/user_profile_dependencies.dart
    abstract class UserProfileDependencies {
      static List<SingleChildWidget> providers() {
        return [
          Provider<IUserProfileRepository>(
            create: (context) => UserProfileRepository(
              apiClient: context.read<ApiClient>(),
            ),
          ),
          Provider<IUserProfileModel>(
            create: (context) => UserProfileModel(
              userProfileRepository: context.read<IUserProfileRepository>(),
            ),
          ),
        ];
      }
    }
    ```

    Затем эти зависимости нужно будет предоставить в `UserProfileScreenBuilder`.

Следуя этому руководству, вы сможете создавать новые фичи, которые будут соответствовать общей архитектуре проекта.
